(* ------------------------------------------------------------ *)
(*                     La logique minimale                      *)
(* ------------------------------------------------------------ *)
tex
	title = "Completeness, minimal logic\\\\ and\\\\ programs extraction"
	author = "Christophe Raffalli"
        institute = "LAMA/Savoie University"
	documents = math
.

flag tex_lisp_app false.
flag auto_lvl 1.

(*! math

\newcommand{\Car}{\hbox{\tt car}}
\newcommand{\Cdr}{\hbox{\tt cdr}}
\newcommand{\Cons}{\hbox{\tt cons}}
\newcommand{\Sub}{\hbox{\tt sub}}
\newcommand{\Succ}{\hbox{\tt succ}}
\newcommand{\Idt}{\hbox{\tt idt}}
\newcommand{\Zero}{\hbox{\tt zero}}
\newcommand{\Nil}{\hbox{\tt nil}}
\newcommand{\KK}{\hbox{\tt K}}
\newcommand{\CW}{\hbox{\tt weak$_{\hbox{\tt\scriptsize cr}}$}}
\newcommand{\CL}{\hbox{\tt lam$_{\hbox{\tt\scriptsize cr}}$}}
\newcommand{\CA}{\hbox{\tt app$_{\hbox{\tt\scriptsize cr}}$}}
\newcommand{\CP}{\hbox{\tt cr}}
\newcommand{\PC}{\hbox{\tt cp}}
\newcommand{\LC}{\hbox{\tt lam$_{\hbox{\tt\scriptsize cp}}$}}
\newcommand{\AC}{\hbox{\tt app$_{\hbox{\tt\scriptsize cp}}$}}

\section{Introduction} 

The Curry-Howard isomorphism \cite{How80}
establishes a correspondence between proofs and programs. We can
extract a correct program from a proof of its specification. But to
what specification corresponds a mathematical theorem like the
completeness theorem ? More precisely, is there a property
characterizing any program extracted from a proof of the completeness
theorem. We will answer this question for the case of minimal logic
\cite{Hey55} using a variation on Kripke semantics \cite{Krip65}.

  We formalize the syntax and the semantics of minimal logic in the
$AF_2$ type system \cite{Kri90e} (This system is the second order
intuitionnistic logic with program extraction).  We prove (theorem
\ref{prvrepr}) that a
$\lambda$-term extracted from a proof of the provability of a formula
$F$ in minimal logic is a {\em Debruijn representation} of a
$\lambda$-term of type $F$ (in simply-typed $\lambda$-calculus). We
mean by a Debruijn representation an encoding of $\lambda$-terms in
$\lambda$-calculus where a bound variable is encoded by the number of
abstractions separating it from its binder.

We establish a similar result (theorem \ref{truthreprbis}) 
for a proof that a formula $F$ is true
in every models, but instead of a Debruijn representation, we get a
{\em higher-order representation}, where bound variables are encoded
using $\lambda$-abstractions. The semantics we use is a variation on
the Kripke semantics \cite{Krip65}. The main difference is the use of
a binary function instead of an ordering. This function can be seen as
the concatenation of two paths in a Kripke tree. Using functions
allows us to use equationnal axioms which enjoy a trivial algorithmic
contents.

From this two results, we deduce (theorem \ref{main}) 
that any term extracted from a proof
of the completeness theorem \ref{completeness} translates an higher-order encoding of a
simply typed $\lambda$-term to the Debruijn encoding of a term of the same
type.  We also get the reverse translation from any proof of the
correctness theorem \ref{correctness}.

An important point in this work is the precise choice of the
definition to simplify as much as possible the term and get only the
essential algorithmic meaning of the theorem. Indeed, the natural
definition of provable and true would have had more information (all
quantifications would have been restricted to formulas or contexts)
inducing some noise in the extracted program.

This simplification of the definitions results in a more general
completeness and correctness theorems than usual. Indeed, we do not
have to know that formulas and contexts are well founded. However, we
need some equational axioms that could be proven if we added the
hypothesis that contexts and formulas were well founded.

Our result is similar to Krivine's result for first-order classical
logic \cite{Kri96}, with one main difference: we find a proof of the
completeness theorem whose extracted term translates an higher-order
encoding of any $\lambda$-term $t$ to the Debruijn encoding of the
same term (see theorem \ref{Cextract}). We think that the same
result is impossible for the classical logic or the intuitionnistic
logic with the disjunction or the existential quantifier (for
semantics similar to the usual Kripke semantics). A proof of these
conjectures would give a concrete argument to say that the semantics
of minimal logic is much simpler and nearer to the syntax than the
semantics of classical logic or the Kripke semantics for the full
intuitionnistic logic. This let us hope that programs extraction could
be a tool to compare the strength of similar theorems which are not
formally related.

One should also note that the completeness and correctness theorems
have been machine checked using the author's implementation of the
$AF_2$ type system. However, the proof about the extracted terms have
not been machine checked (this would require a formalization of the
$AF_2$ realizability yet to be done).

\section{Preliminaries} We use Krivine's notation for the
$\lambda$-calculus (except for the application were we use the standard
LISP notation) and his notation and results for
the $AF_2$ type system \cite{Kri90e}.

To avoid confusion, we use $\Gamma \vdash_S t : F$ for sequent in
simply-typed $\lambda$-calculus and $\Gamma \vdash_{AF_2} t : F$ for
$AF_2$ sequent. Moreover, we use the following abbreviations and
notations:
\begin{itemize}
\item $A \rightarrow B \rightarrow C $ for $A \rightarrow (B \rightarrow C) $
\item $\forall x A \rightarrow B$ for $(\forall x A) \rightarrow B$
\item $\forall x,y{:}A \;B$ for $\forall x (A(x) \rightarrow \forall y
(A(y) \rightarrow B))$.
\item $\Lambda$ is the set of all $\lambda$-terms.
\item ${\mathcal P}_\beta(\Lambda)$ is the set of subsets of $\Lambda$ closed under
$\beta$-equivalence
\end{itemize}

We recall the following definitions and lemma from \cite{Kri90e}:

\begin{defn}[Interpretation] An {\em interpretation} $\sigma$:
is given by three mappings: 
\begin{itemize}
\item A mapping from first order variables to $\lambda$-terms denoted $x
\mapsto |x|^\sigma$
\item A mapping from function symbols of arity $n$ to $n$-ary functions
from $\Lambda^n$ to $\Lambda$ denoted $f
\mapsto |f|^\sigma$
\item A mapping from predicate variables of arity $n$ to $n$-ary functions
from $\Lambda^n$ to ${\mathcal P}(\Lambda)_\beta$  denoted $X
\mapsto |X|^\sigma$
\end{itemize}
As usual, we write $\sigma[x \Leftarrow t]$ or $\sigma[X
\Leftarrow \Phi]$ when we change the value of the mapping $\sigma$ for $x$ or
$X$ only.
This mapping is extended to any term and formula by:
\begin{itemize}
\item $|f(t_1,\dots,t_n)|^\sigma = |f|^\sigma(|t_1|^\sigma,\dots,|t_n|^\sigma)$
\item $|X(t_1,\dots,t_n)|^\sigma = |X|^\sigma(|t_1|^\sigma,\dots,|t_n|^\sigma)$
\item $|A \rightarrow B|^\sigma = \\{t \in \Lambda; \forall u \in
|A|^\sigma, (t\,u) \in |B|^\sigma \}$
\item $|\forall x\,A|^\sigma = \bigcap_{t\in\Lambda} |A|^{\sigma[x \Leftarrow t]}$
\item $|\forall X\,A|^\sigma = \bigcap_{\Phi\in\Lambda^n \rightarrow
{\mathcal P}_\beta(\Lambda)} |A|^{\sigma[X \Leftarrow \Phi]}$
\end{itemize}
\end{defn}

\begin{lem}[Adequation lemma]\label{adeq}
For any formula $A$ and any interpretation $\sigma$, we have
$$ \vdash_{AF_2} t : F \hbox{ implies } t \in |F|^\sigma $$
\end{lem}

\begin{defn}[Data types]\label{datadef} A predicate $D$ of
  arity one is a {\em data-type}\footnote{Krivine also states that
  $|D(v)|^\sigma$ is non empty if and only if $t$ is intentionnally of
  type $D$ (for integer this means that if $|{\mathbb N}(v)|^\sigma$
  is non empty then $v$ really represents an integer). We do not use
  this, this is why we give a simplified definition.} for an
  interpretation $\sigma$ if and only if for any first order term $v$
  and any $\lambda$-term $t$, $t \in |D(v)|^\sigma$ implies $t
  \sim_\beta |v|^\sigma$.  \end{defn}
 
\section{The formalization of minimal logic}
*)

Import nat.

def Var = N.
tex_syntax Var Math "{\\mathcal V}".

Sort form.
Cst Prefix [3] "var" x : nat -> form.
tex_syntax $var Prefix[3] "\\overline{" ! x ! "}".

Cst rInfix [4] x "|->" y : form -> form -> form.
tex_syntax $|-> rInfix [4] x "\\Rightarrow" y.

def Form f = /\X (
	/\x (Var x -> X (var x)) ->
	/\g,h (X g -> X h -> X (g |-> h)) -> X f ).
tex_syntax Form Math "{\\mathcal F}".


goal /\x:Var Form (var x). 
trivial. (* à remplacer ! *)
save var.Form.

goal /\f,g:Form Form (f |-> g). 
trivial. (* à remplacer ! *)
save impl.Form.

new_intro -c -i var var.Form.
new_intro -c -i impl impl.Form.

goal /\X (
	/\x:Var  X (var x) -> 
	/\g,h:Form (X g -> X h -> X (g |-> h)) ->
  /\f:Form X f).
intros.
prove Form f & X f.
next 1.
left G.
elim H1.
trivial.
trivial.
save rec.Form.

new_elim Form rec rec.Form.

(*! math
\begin{defn}
Let us choose an infinite countable set of variables $\[ Var \]$, one
unary function symbol $x \mapsto \[ var x \]$ and one
binary function symbol $\[ f |-> g \]$. We define the set of formulas as
the smallest set such that\footnote{We cannot identify the formula $x$ and
the variable $x$ if we want the proposition \ref{data} to hold}:
$$
 \[ $$var.Form \] \;\;\;\text{and}\;\;\; \[ $$impl.Form \]
$$
This is formally defined by the following second-order formula:
$$
  \[ Form f \] = \[ $$Form f \]
$$
\end{defn}

*)

Import list.
tex_syntax $:: rInfix[4] x ! "\\," ! y.


def Prouvable C f = /\X (
	/\f,C X (f::C) f -> 
	/\f,g,C (X C f -> X (g::C) f) ->
	/\f,g,C (X (f::C) g -> X C (f |-> g)) ->
        /\f,g,C (X C (f |-> g) -> X C f -> X C g) -> 
          X C f).
tex_syntax Prouvable Infix[5] C "\\Vdash" f.

(* les règles d'intros *)

goal /\C,f Prouvable (f::C) f.
trivial.
save Axiome.

goal /\C,f,g (Prouvable C f -> Prouvable (g::C) f).
trivial.
save Affaiblissement.

goal /\C,f,g (Prouvable (f::C) g -> Prouvable C (f |-> g)).
trivial.
save Impl_intro.

goal /\C,f,g (Prouvable C (f |-> g) -> Prouvable C f -> Prouvable C g).
trivial.
save Impl_elim.

new_intro fe Impl_elim.
new_intro -i ax Axiome. 
new_intro af Affaiblissement. 
new_intro fi Impl_intro. 

goal  /\X (
	/\f,C X (f::C) f ->            
	/\f,g,C (Prouvable C f -> X C f -> X (g::C) f) ->
	/\f,g,C (Prouvable (f::C) g -> X (f::C) g -> X C (f |-> g)) ->
        /\f,g,C (Prouvable C (f |-> g) -> Prouvable C f -> 
			X C (f |-> g) -> X C f -> X C g)
	-> /\f,C (Prouvable C f -> X C f)).
intros.
prove Prouvable C f & X C f.
elim H3.
trivial.
trivial.
trivial.
trivial.
trivial.
save rec.Prouvable.

new_elim Prouvable rec rec.Prouvable.

(*!math

\begin{defn} We define contexts as ordered lists. We use a
symbol \[ nil \] for the empty list and a binary function symbol {\em
cons} written $a, y \mapsto \[ a:: y \]$ to construct lists. The
predicate defining lists of elements of $D$ is: $$ \[ List D l \] = \[
$$List D l \] $$
\end{defn}

\begin{thm}\label{data}
The predicates $\[ Form \]$ and 
$\[ List Form  \]$ are data-types (definition \ref{datadef}) for an interpretation $\sigma$ if the
following holds:
\begin{itemize}
\item The predicate  $\[ Var \]$ defining variables is a data-type for $\sigma$
\item $| \[ var x \] |^\sigma \sim_\beta \lambda a \lambda b (a\, |x|^\sigma)$
\item $| \[ f |-> g \] |^\sigma \sim_\beta \lambda a \lambda b (b\, |f|^\sigma
\,|g|^\sigma)$
\item $| \[ nil \] |^\sigma \sim_\beta \lambda a \lambda b\,a$
\item $| \[ x::l \] |^\sigma \sim_\beta \lambda a \lambda b (b\, |x|^\sigma\,
|l|^\sigma)$
\end{itemize}
\end{thm}

\begin{proof}
The proofs for lists and trees can be found in \cite{Kri90e} and the proof for 
formulas is identical to the proof for trees. \qed
\end{proof}

\begin{defn}
We define the provability as the smallest binary relation \[ Prouvable
\] such that:
$$
\begin{array}{ll}
\[ /\C,f {{ Prouvable (f::C) f }} \] & \text{(axiom)} \cr
\[ $$Affaiblissement \] & \text{(weakening)} \cr
\[ $$Impl_intro \] & \text{(implication introduction)} \cr
\[ $$Impl_elim \] & \text{(implication elimination)} \cr
\end{array}
$$
Formally this predicate is defined by the following second-order predicate:
$$
\[[ Prouvable C f \]] = {\textwidth=10.6cm \[[ $$Prouvable C f \]] }
$$
\end{defn}

One should note that with this definition, \[ Prouvable C f \] does
not imply that $\[ C \]$ is a list of formulas or $\[ f \]$ is a
formula. We could add more conditions in the definition, but the
$\lambda$-term extracted from a proof of $\[ Prouvable C f \]$ will
then be more complex.

\begin{defn}
We say that a $\lambda$-term $t$ is an internal Debruijn
representation of a closed 
term $u$ if $t = \lambda z \lambda s \lambda l
\lambda a\,t'$ and $||t'||_{\emptyset} = u$ where $||t'||_c$ is the partial
function taking as arguments a term and a list of variables and defined by
\begin{itemize}
\item $||z||_{xc} = x$.
\item $||(s\,t_1)||_{xc} = ||t_1||_{c}$.
\item $||(l\,t_1) ||_c = \lambda x ||t_1||_{xc}$ where $x \not\in c$.
\item $||(a\,t_1\,t_2)||_c = (||t_1||_c\,||t_2||_c)$.
\end{itemize}
Formally, the definition of $||t'||_c$ depends on the choice of the
variables $z,s,l,a$ but we omit these parameters in the notation.  
\end{defn}

You may notice that the internal Debruijn representations of a term $u$
are not unique because of the freedom in the position of the weakening
denoted by the variable $s$ (usually, weakenings only occur at the
variable level). For instance, $\lambda z \lambda s \lambda l \lambda
a\,(l\,(l\,(s\,(a\,z\,z))))$ and $\lambda z \lambda s \lambda l \lambda
a\,(l\,(l\,(a\,(s\,z)(s,z))))$ are two internal Debruijn representations for
the term $\lambda x \lambda y (x\,x)$.
 
\begin{thm}\label{prvrepr}
For any term $t$ and any formula $f$, if $\vdash_{AF_2} t
: (\[ Prouvable nil f \])$ then $t$ is $\beta$-equivalent to an 
internal Debruijn representation of a closed $\lambda$-term $u$ such that
$\vdash_{S} u : \[ f \]$.  
\end{thm}

This theorem means that a term $t$ extracted form a proof, in
second-order logic, that a formula $f$ is provable in minimal logic is an
internal Debruijn representation of a term $u$ of type $f$ in
simply-typed $\lambda$-calculus.

\begin{proof}
To prove this theorem, we use the adequation lemma, which implies that
for any interpretation $\sigma$ we have $t \in |\[ Prouvable nil f
\] |^\sigma$.

We choose an interpretation $\sigma$ such that for any first-order
terms $\phi$ and $\phi'$ designing formulas or lists of formulas, we have
$|\phi|^\sigma \sim_\beta |\phi'|^\sigma$ implies $\phi = \phi'$ (i). Such an
interpretation exists, we just need to choose $\sigma$ such that the
type of formulas and lists of formulas are data-types using
proposition \ref{data}.

We choose four $\lambda$-variables $z,s,a,l$ not free in $t$ and we
define, for any $\lambda$-terms $t,t'$, $\Phi(t,t')$ the
smallest sets closed under
$\beta$-equivalence such that:
\begin{itemize} 
\item $z \in \Phi(|\[ fC\] |^\sigma, |\[ f\] |^\sigma)$
\item $(s\,t_1) \in \Phi(|\[ gC\] |^\sigma, |\[ f\] |^\sigma)$ 
        if $t_1 \in \Phi(|\[ C\] |^\sigma, |\[ f\] |^\sigma)$
\item $(l\,t_1) \in \Phi(|\[ C\] |^\sigma, |\[ f |-> g \] |^\sigma)$ 
        if $t_1 \in \Phi(|\[ fC\] |^\sigma, |\[ g\] |^\sigma)$
\item $(a\,t_1\,t_2) \in \Phi(|\[ C\] |^\sigma, |\[ g\] |^\sigma)$ 
        if $t_1 \in \Phi(|\[ C\] |^\sigma, |\[ f\] |^\sigma)$
        and $t_2 \in \Phi(|\[ C\] |^\sigma, |\[ f |-> g\] |^\sigma)$
\end{itemize}

We first show, by induction on the definition of $\Phi$, that  $t_1
\in \Phi(|C|^\sigma, |f|^\sigma)$, $t_1$ normal, $l =
x_1\dots x_n$ with the $x_i$ distinct and $C = f_1\dots f_n$ implies
$x_1 : f_1,\dots, x_n:f_n \vdash_S ||t_1||_l : f$ (ii).  Each case in the
induction is immediate using the property (i) and the definition of
$\Phi$ and $||t_1||_l$.

Then we define the interpretation $\sigma' = \sigma[X/\Phi]$ and 
we prove the following properties:
\begin{itemize}
\item $z \in |\[/\f,C X (f::C) f\] |^{\sigma'}$
\item $s \in |\[/\f,g,C (X C f -> X (g::C) f)\] |^{\sigma'}$
\item $l \in |\[/\f,g,C (X (f::C) g -> X C (f |-> g))\] |^{\sigma'}$
\item $a \in |\[/\f,g,C (X C (f |-> g) -> X C f -> X C g)\] |^{\sigma'}$
\end{itemize}
This is immediate: when we apply the definition of the interpretation,
each condition corresponds to one of the condition in the definition of
$\Phi$.

Then, we have $t \in |\[ Prouvable nil f \] |^\sigma$ implies
$(t\,z\,s\,l\,a) \in |\[X C f\] |^{\sigma'} = \Phi(|\[nil\] |^\sigma,
|f|^\sigma)$.  Thus, using (ii) we find $(t\,z\,s\,l\,a) \sim_\beta t'$
with $\vdash_S ||t'||_\emptyset : f$.  This means that $t$ is
$\beta$-equivalent to a term starting with four abstractions
(otherwise $||t'||_\emptyset$ would be undefined) which implies $t \sim_\beta \lambda z \lambda s
\lambda l \lambda a\,t'$ (because $z,s,a,l$ are
not free in $t$). Thus $t$ is an internal Debruijn
representation of a term $u$ ($u = ||t'||_\emptyset$) with $\vdash_S u
: f$. \qed
\end{proof}

\section{Formalization of the semantics of minimal logic}
*)


def M0 h = /\p,q,r (h p (h q r) = h (h p q) r).
def M1 h e = /\p (h e p = p).
def M2 h M = 
    /\f,g,p (/\q(/\r M (h r (h q p)) f -> M (h q p) g) -> M p (f |-> g)).
def M3 M = 
    /\f,g,p (M p (f |-> g) -> M p f -> M p g).

def Truth M o e f = M0 o -> M1 o e -> M2 o M -> M3 M -> /\p M p f.

Cst h : 'a -> 'a -> 'a.
tex_syntax h Infix[4] x "\\circ" y. 
  
(*! math
\begin{defn}
A model is given by a binary operation \[ h \] , a constant \[ e \] , and a
predicate \[ M \] satisfying the following conditions:
\begin{itemize}
\item $\[ M0 h \] = \[ $$M0 h \]$ \hspace{7mm}(\[ h \] is associative) 
\item $\[ M1 h e\] = \[ $$M1 h e\]$ 
\item $\[ M2 h M \] = {\textwidth=10cm \[[ $$M2 h M \]] }$ 
\item $\[ M3 M \] = \[ $$M3 M \]$ 
\end{itemize}
\end{defn}

Such a model is very similar to a kripke tree model. Indeed, if we
consider that a point in a tree is denoted by his path and that \[ h \] is
the concatenation of paths in a tree, then our definition is equivalent
to the usual one. We just replace $p > q$ by \[ p = h r q \].

The only difference is that we do not require the
truth to increase when we climb in the tree. Instead, in $\[ M2 \]$, we
check that the formula is true at every point above $\[ h q p \]$.
The truth of $\[ f \]$ at $\[ p \]$ is not $\[ M p f \]$ but $\[ /\q M (h q
p) f \]$.

*)

del h.

(*!math

\begin{defn}
The truth can be defined as being true in every model. This is
formalized by the following predicate:
$$ 
\[ Truth M o e f \] = {\textwidth=10.7cm \[[ $$Truth M o e f \]] }
$$
\end{defn}

\begin{defn}
We say that a $\lambda$-term $t$ is an higher-order
representation of a term $u$ if $t$ is closed, $t =
 \lambda l \lambda a\,t'$ and 
$||t'|| = u$ where $||t'||$ is the partial
function taking a term as argument and defined by:
\begin{itemize}
\item $||x|| = x$.
\item $||(l\,\lambda x\,t_1) || = \lambda x ||t_1||$.
\item $||(l\,t_1) || = \lambda x ||(t_1 \, x)||$ if $t_1$ does not
start with $\lambda$ and $x$ not free in $t_1$.
\item $||(a\,t_1\,t_2)|| = (||t_1||\,||t_2||)$.
\end{itemize}
This definition is well founded, because the number of occurrences of
$l$ or $a$ decreases in each recursive call.
Formally, $||t'||$ depends on the choice of the variables $l$ and $a$
but we omit these parameters in the notation.  
\end{defn}


We need the two cases for $l$, because we can extract terms
containing sub-terms of the form $(l\,(a,t)) \sim_\eta (l\,\lambda x (a\,t\,
x))$ from proofs of $\[ Truth M o e f \]$. 

\begin{prop}\label{truthrepr}
For any term $t$ and any formula $f$, if $\vdash_{AF_2} t
: \[ Truth M o e f \]$ then $(t\,(\lambda x\,x)\,(\lambda x\,x))$ is
$\beta$-equivalent to an
higher-order representation of a closed $\lambda$-term $u$.
\end{prop}


This proposition is weaker that the
corresponding theorem \ref{prvrepr} for provability. The stronger
theorem that also states that $u$ is of type $f$ will be given later
(theorem \ref{truthreprbis}).

\begin{proof}
Let us call \[ T \] the follwing formula: 
$$ \[ T \] = {\textwidth=10.7cm \[[ /\M (/\X (X -> X) -> /\X (X -> X) -> ((M -> M) -> M) -> (M -> M ->
M) -> M)\]] }$$
This formula is obtained from \[ Truth M o e f \] by erasing all
first-order information. 

We choose $t$ such that $\vdash_{AF_2} t : \[ Truth M o e f
\]$. Therefore, we have $\vdash_{AF_2} t : \[ T \]$ and using the
adequation lemma, we have $t \in |\[ T \] |^\sigma$ for any
interpretation $\sigma$.

We choose two $\lambda$-variables $a,l$ and an infinite set of
variables $\\{x_{n}\}_{n \in \[ N \] }$
not free in $t$.
We define $\Phi$ the
smallest set closed under
$\beta$-equivalence such that:
\begin{itemize} 
\item $x_{n} \in \Phi$ for all $n \in \[ N \]$
\item $(l\,t_1) \in \Phi$ 
        if $\forall n \in \[ N \] \, (t_1\,x_n) \in \Phi$ 
\item $(a\,t_1\,t_2) \in \Phi$ 
        if $t_1 \in \Phi$
        and $t_2 \in \Phi$
\end{itemize}

We show, by induction on the definition of $\Phi$, that 
$t \in \Phi$ and $t$ normal imply 
that $||t||$ is defined (i) and the free variables of 
$||t||$ are among $\\{a,b\} \cup \\{x_{n}\}_{n \in \[ N \] }$ (ii).
The only non trivial case is when $t = (l\,t_1)$. Then we choose  $x_n$ not
free in $t_1$ and and we distinguish two
cases:
\begin{itemize}
\item If $t_1$ does not start with $\lambda$, we have $(t_1\,x_n) \in \Phi$ and normal (by definition of
$\Phi$). By induction hypothesis, we get $||(t_1\,x_n)||$ defined and
(ii) for $(t_1\,x_n)$. Therefore $||(l\,t_1)|| = \lambda x_n\,||(t_1\,x_n)||$ is defined and
$(l\,t_1)$ satisfies (ii).
\item If $t_1 = \lambda x\,t_2$ then 
$t_2[x/x_n]$ is normal and $t_2[x/x_n] \in \Phi$. Thus by induction
hypothesis, we get $||t_2[x/x_n]||$ defined and
(ii) for $t_2[x/x_n]$. Therefore $||(l\,t_1)|| = \lambda x\,||t_2|| =
\lambda x_n\,||t_2[x/x_n]||$ is defined (because $||t_1[x/y]|| =
||t_1||[x/y]$ is immediate by induction on $t_1$) and
$(l\,t_1)$ satisfies (ii).
\end{itemize}

We define the interpretation $\sigma' = \sigma[M/\Phi]$ and we prove
the following properties: \begin{itemize} \item $\lambda x\,x \in
|\[/\X(X -> X)\] |^{\sigma'}$ \item $l \in |\[(M -> M) -> M\]
|^{\sigma'}$ \item $a \in |\[M -> M -> M\] |^{\sigma'}$ \end{itemize}
The first condition is trivial and the last one uses the third case in
the definition of $\Phi$. For the second one, we choose $v \in \Phi
\rightarrow \Phi$ and we must prove $(l\,v) \in \Phi$. For any $n \in
\[ N \]$ we find $(v\,x_n) \in \Phi$ because $x_n \in \Phi$. Thus, we
have $(l\,v) \in \Phi$.

Therefore, we have $t \in |\[ T \] |^\sigma$ implies $(t)\lambda
x\,x\;\lambda x\,x\;l\;a \in |\[M\] |^{\sigma'} = \Phi$.  Thus, using
(ii) we find $t' \sim_{\beta} (t\,(\lambda x\,x)\,(\lambda x\,x)\,l\,a)$
with $||t'||$ defined. From this we get $(t\,(\lambda x\,x)\,(\lambda x\,x))
\sim_{\beta} \lambda l \lambda a\,t'$ (because $a,l$ are not free
in $t$) with $\lambda l \lambda a\,t'$ closed (because the $x_n$
variables were also chosen not free in $t$). We have what we wanted:
$(t\,(\lambda x\,x)\,(\lambda x\,x))$ is an higher-order representation of
$||t'||$. \qed \end{proof}

\section{Correctness}

*)

goal /\f (Prouvable nil f -> /\M,o,e Truth M o e f).
(*! math
\begin{thm}[Correctness of the semantics]\label{correctness}
$$ \[ $0 \] $$ 
\end{thm}

\begin{proof} Together with the proof, we give the extracted term.
*)
intros.
intros.
tex_syntax o Infix[4] x "\\circ" y.
unfold_hyp H1 M1.
unfold_hyp H0 M0.
(*! math
We assume $\[ $$H \]$ and we choose an arbitrary model defined by \[ o
\] , \[ e \] , \[ M \]. We must prove \[ $0 \].
*)
local M_L p C = /\q List \f (M (o q p) f) C.
(*! math
We define the following predicate:
$$ \[  M_L p C \] = \[ $$M_L p C \] $$
\[  M_L p C \] means that C is a list of formulas true at any point
above p.
*)
(* lemme *)
prove -head /\p,f,c (M_L p (f::c) -> /\q M (o q p) f).
intros.
elim H4 with [case] ;; trivial.
(* lemme *)
prove -tail /\p,f,c (M_L p (f::c) -> M_L p c).
intros.
intro.
elim H4 with [case] ;; trivial.

(*! math
We easily prove the following lemmas about \[ M_L \] :
\begin{enumerate}
\item $\[ $$head \]$
\item $\[ $$tail \]$
\end{enumerate}
The term $\Car$ and $\Cdr$ extracted respectively from (1) and (2)
implement the usual destructors for lists (this is an easy consequence
of the proposition \ref{data} and the adequation lemma). 
*) 
(* debut de la preuve: on généralise: *)
(*! math
Now to do the induction, we substitute the following predicate  
to the variable $X$ in $\[ $$ H \]$:
$$\[ \C \f /\p (M_L p C -> /\q M (h q p) f) \]$$
Therefore, we will get the expected conclusion \[ $0 \] if we prove the
following properties:
\begin{itemize}
*)
prove /\p (M_L p nil -> /\q M (o q p) f).
(* 
On ne veut pas utiliser rec.Prouvable 
	(pour obtenir un terme extrait plus court !
On ouvre donc la définition a la main !
*) 
unfold_hyp H Prouvable.
(*
et on fait l'induction !
*)
elim H.
(*! math
\item $\[ $0 \]$ which is (1).
*)
(* cas de l'axiome *)
intros.
elim -4 H4 head. 
(* cas affaiblissement *)
(*! math
\item {\textwidth=11cm $\[[ $0 \]]$} which is immediate using (2).
The extracted term is $\CW = \lambda u \lambda c (u\,(\Cdr\,c))$.
*)
intros.
elim H4.
elim -4 H5 tail. 
(* cas de l'impl_introduction *)
(*! math
\item {\textwidth=11cm $\[[ $0 \]]$}
which is easy using \[ $$H0 \] , \[ $$H1 \] and $l : \[ $$H2 \]$.
The extracted term is $\CL[l] = \lambda u \lambda c (l\,\lambda x (u\,(\Cons\,x\,c)))$
where $\hbox{\Cons}$ implements the expected operation on lists.
*)
intros.
elim H2.
intros.
elim -1 (o q0 (o q p0)) H4.
intro.
intro.
elim H6.
elim H5.
(* cas de l'impl_élimination *)
(*! math
\item {\textwidth=11cm $\[[ $0 \]]$} 
which is easy using \[ $$H0 \] , \[ $$H1 \] and $a : \[ $$H3 \]$.
The extracted term is $\CA[a] = \lambda u \lambda v \lambda c (a\,(u\,c)\,(v\,c))$.
*)
intros.
elim H3.
elim -1 (o q p0) H4.
intro.
elim H6.
elim -1 (o q p0) H5.
intro.
elim H6.
elim G.
(*! math
\item \[ $0 \] which is trivial.
The extracted term is $\Nil = \lambda x \lambda f\,x$. 
*)
intro.
intro.
save Correcte.
(*!math
\end{itemize} 
The term extracted from the all proof is
$$\CP = \lambda t \lambda e_1 \lambda e_2 \lambda l \lambda a (t \;\Car \;\CW \;\CL[l] \;\CA[a] \;\Nil)$$
\end{proof}

\begin{lem}
We define $\sigma = [z/\Car,s/\CW,l/\CL[l],a/\CA[a]]$ and, for $c =
x_n\dots x_1$, $\overline{c} = 
\lambda a \lambda f (f\,x_n\,(f\,x_{n-1}\,\dots(f\,x_1\,a)\dots))$.  We have $||t'||_c
= u$ implies that $t''$ the normal form of $(t'\sigma)\overline{c}$
exists and $||t''|| = u$.
\end{lem}

\begin{proof}
We prove this by induction on the term $t'$. By definition of 
 $||t'||_c$, we are in one of the following cases:
\begin{itemize}
\item If $t' = z$ then $(t'\sigma\,\overline{c}) \sim_\beta
(\Car\,\overline{c})$. As $||z||_c$ is defined, $c$ starts with a
variable $x$ and $u = x$. We can take $t'' = x$.
\item If $t' = (s\,t'_1)$ then $(t'\sigma\,\overline{c}) \sim_\beta
(\CW\,t'_1\sigma\,\overline{c}) \sim_\beta
(t'_1\sigma\,(\Cdr,\overline{c}))$.
We have $c = x c'$ and $||t'||_c = ||t'_1||_{c'} = u$
which gives what we want using the induction hypothesis.
\item If $t' = (l\,t'_1)$ then  $(t'\sigma\,\overline{c}) \sim_\beta
(\CL[l]\,t'_1\sigma\,\overline{c}) \sim_\beta
(l\,\lambda x(t'_1\sigma\,(\hbox{\it Cons}\,x\,\overline{c})))$. We have $||t'||_c = \lambda x
||t'_1||_{xc}$
and the induction hypothesis gives $(t'_1\sigma\,(\hbox{\it Cons}\,x\,\overline{c})) \sim_\beta
t''_1$ normal
with $||t''_1|| = ||t'_1||_{xc}$. 
Then, we take $t'' = (l\,\lambda x\,t''_1)$ and we get
what we expected.
\item If $t' = (a\,t'_1\,t'_2)$ then  $(t'\sigma\,\overline{c}) \sim_\beta
(\CA[a]\,t'_1\sigma\,t'_2\sigma\,\overline{c}) \sim_\beta
(a\,(t'_1\sigma\,\overline{c})\,(t'_2\sigma\,\overline{c}))$.
We have $||t'||_c = (||t'_1||_c)||t'_2||_c$
and the induction hypothesis gives $(t'_1\sigma)c \sim_\beta
t''_1$ normal
with $||t''_1|| = ||t'_1||_c$ and the same for $t'_2$. 
We take $t'' = (a\,t''_1\,t''_2)$ and we get
what we wanted. \qed
\end{itemize}
\end{proof}


\begin{thm}\label{extractone} 
If $t$ is $\beta$-quivalent to
an internal Debruijn representation of a term $u$ then $(\CP\,t)$ is
$\beta$-equivalent to an higher-order representation of $u$.
\end{thm}

\begin{proof} Let $t$ be an internal Debruijn representation of a term
$u$.  We have $t \sim_\beta \lambda z \lambda s \lambda l \lambda a
\,t'$ with $||t'||_\emptyset = u$. Then $(\CP\,t) \sim_\beta \lambda e_1
\lambda e_2 \lambda l \lambda a (t'\sigma\,\overline{\emptyset})$
where $\sigma$ is the substitution
defined in the proof of the previous lemma (because $\Nil = \overline{\emptyset}$).  From the definition of
$\sigma$, we know that $a$ and $l$ are the only free variables of
$(t'\sigma\,\overline{\emptyset})$ Therefore, using the previous lemma,
$(\CP\;t\;(\lambda z\,z)\;(\lambda z\,z)) \sim_beta \lambda l \lambda a
(t'\sigma\,\overline{\emptyset})$ and the normal form $t''$ of
$(t'\sigma\,\overline{\emptyset})$ exists and verifies $||t''|| = u$. \qed
\end{proof} *)


(*!math
\section{Completeness}

Before proving the completeness of our semantics, we need a few
definition and axioms:
*)

def UList l = /\X (X nil -> /\a,l' (X l' -> X (a::l')) -> X l).
tex_syntax UList Math "\\rm I\\hspace{-0.2em}L".

(*! math
\begin{defn}
We define the type of untyped list by 
$$ \[ UList l \] = \[ $$UList l \] $$
\end{defn}

\begin{lem}\label{UList}
If $\vdash_{AF2} t : \[ UList l \] $ then $t$ is $\beta$-equivalent to
the church numeral $\overline{n} = \lambda x \lambda f (f^n\,x)$ where $n$ 
is the length of the list $l$.
\end{lem}

\begin{proof}
The proof is exactly the same as the proof for the type of Church
numeral itself (see \cite{Kri90e}). \qed
\end{proof}

*)

(*
définition d'une fonction sur les listes:
*)

claim append.associative.untyped /\l,l',l'' (l @ (l' @ l'') = (l @ l') @ l''). 
new_equation append.associative.untyped.

claim append.nil_right.untyped /\l (l @ nil = l). 
new_equation append.nil_right.untyped.

claim append.nil_left.untyped /\l (nil @ l = l). 
new_equation append.nil_left.untyped.

claim append.cons.untyped /\a,l,l' (a:: l @ l' = a:: (l @ l')). 
new_equation append.cons.untyped.

Cst tail_total : list['a] -> list['a].
claim tail_total0 tail_total nil = nil.
claim tail_total1 /\a tail_total (a:: nil) = nil.
claim tail_total2 /\l,l',a tail_total (l@(a::l')) = l@tail_total(a::l').
new_equation tail_total0.
new_equation tail_total1.
new_equation tail_total2.

(*! math

\begin{defn}
To prove the completeness theorem, we need to add one binary function
symbol \[ l @ l' \] for the concatenation of lists and a unary
function symbol \[ tail_total l \] for the function removing the last
element in a list.
\end{defn}

\begin{axiom}
We then assume the following axioms:
\begin{itemize}
\item \[ $$append.cons.untyped \]
\item \[ $$append.nil_left.untyped \]
\item \[ $$append.nil_right.untyped \]
\item \[ /\l,l',l'' (l @ {{l' @ l''}} = (l @ l') @ l'') \]
\item \[ $$tail_total0 \]
\item \[ $$tail_total1 \]
\item \[ $$tail_total2 \]
\end{itemize}
\end{axiom}

Remark: we could prove the completeness theorem without axioms if we
added some extra conditions in the definition of models. But this
would pollute the extracted terms.


*)

(*
QUESTION: que fait-elle ?
*)

(*
Voici la preuve de totalité de cette fonction:
*)

goal UList nil.
trivial.
save nil.UList.

goal /\a,l (UList l -> UList (a::l)).
trivial.
save cons.UList.

new_intro -i nil nil.UList.
new_intro -i cons cons.UList.

goal  /\X (X nil -> /\a/\l':UList (X l' -> X (a::l')) -> /\l:UList X l).
intros.
prove UList l & $0.
elim H1.
trivial.
trivial.
trivial.
save rec.UList.
new_elim UList rec rec.UList.

goal /\l:UList (l = nil or \/a\/l':UList l = a::l').
trivial.
save case.UList.
new_elim -n UList case case.UList.

goal /\l (UList l -> UList (tail_total l)).
intros.
elim H.
trivial.
elim -1 [case] H0.
trivial.
lefts H2 $\/ $&.
from UList (tail_total (a::nil @  l')).
rewrite tail_total2.
rewrite append.lcons.List append.lnil.List .
intro.
from H1.
save tail_total.total.
new_intro -t tail_total tail_total.total.
tex_syntax tail_total.total "(i)".

goal /\l,a (UList (l@ a::nil) -> UList l).
intros.
from UList (tail_total (l@ a::nil)).
intro.
save lemma1.
tex_syntax lemma1 "(ii)".

goal /\l1,l2 (UList (l2@l1) -> UList l1 -> UList l2).
intros.
prove /\l2 (UList (l2 @ l1) -> UList l2).
elim H0.
trivial.
intros.
elim lemma1.
instance ?1 a.
elim H2.
from H3.
elim G.
save lemma2.
tex_syntax lemma2 "(iii)".

(*! math
\begin{lem}\label{sublem}
We can prove the following: \[ $$lemma2 \]
\end{lem}

\begin{proof}
We first prove \[ $$tail_total.total \] by an easy induction on the structure of
the list. Then \[ $$lemma1 \] (i) follows easily. To prove the lemma, we
proceed by induction on the
structure of the list \[ l1 \] using (i) for the cons case. \qed
\end{proof}

\begin{lem} \label{subext}
If $t$ is a term extracted from a proof of lemma \ref{sublem}
then $t$ computes the subtraction of two Church integers (when the
first argument is greater or equal to the second one). 
\end{lem}

\begin{proof}
This is an immediate consequence of the lemma \ref{UList}. \qed
\end{proof}
*)

goal /\f (/\M/\o/\e:<list[form] Truth M o e f -> Prouvable nil f).
(*! math
\begin{thm}\label{completeness}
The semantics is complete: 
$$ \[ $0 \] $$
\end{thm}

\begin{proof}
Together with the proof, we will construct the extracted term.
*)
intros.
unfold Prouvable.
intros.
(*! math
Using the definition of \[ Prouvable \] , we prove \[ $0 \] using
the following hypothesis:
\begin{enumerate}
\item $x : \[$$H \]$ 
\item $z : \[$$H0\]$ 
\item $s : \[$$H1\]$
\item $l : \[$$H2\]$
\item $a : \[$$H3\]$
\end{enumerate}
We replace \[ o \] by the concatenation of lists,
$e$ by \[ nil \] and \[ M \] by \[ \C,f (UList C -> X C f) \] in (1).
This means that we consider the model whose points are contexts and
where \[ X \] defines the truth.
Thus we have to prove the following: 
\begin{itemize}
*)
elim -2 $@ -3 nil -1 \C,f (UList C -> X C f) H.
(*! math
\item \[ $0 \] and \[1 $0 \] are among the axioms we assumed. We can
always consider that $\Idt = \lambda x\,x$ is the algorithmic content of
the equational axioms to extract a term from these axioms.
*)
trivial.
trivial.
(*! math
\item To prove \[ $0 \] , we assume
*)
intros.
(*! math 
\begin{itemize}
\item $f : {\textwidth=10cm \[[ $$H4 \]] }$ (i)
\item $n : \[ $$H5 \]$ (ii)
\end{itemize}
and we must prove \[ $0 \].
*)
elim H2.
elim H4.
(*! math
Using (4) and (i), we just need to prove \[ $0 \] and \[1 $0 \]. The
second one is immediate from (ii).
*)
next 1.
trivial.
intros.
(*!math
For the first one, we assume $p : \[ $$H6 \]$ and we will prove
\[ $0 \].
*)
prove UList r.
elim lemma2.
from H6.
trivial = H5.
(*! math
Using lemma\ref{sublem}, $n : \[ $$H5 \]$ and $p : \[ $$H6 \]$, we get $(\Sub\,p\,(\Succ\,n)) : \[
$$G \]$ ($\Succ$ is
a term computing the successor of a Church numeral and by lemma \ref{subext}, $\Sub$
is a term computing the subtraction of two Church numerals).
*)  
unfold_hyp G UList.
(*! math 
Then we prove \[ $0 \] by induction on \[ r \].
*)
elim G.
(*! math 
 For the nil case, we get \[ $0 \] using our equational axioms and (2).
*)
elim H0.
intro 2.
(*! math 
 For the cons case, we get \[ $0 \] using
 (3). The term extracted from this sub-proof is
$$\LC[l] = \lambda f \lambda n\,(l\;(f\;(\lambda p\,(\Sub\;p\;(\Succ\,n)\;z\;s))\;(\Succ\,n)))$$
*)
elim H1.
(*! math
\item To prove \[ $0 \] , we just need to use (5) and the extracted
term is $$\AC[a] = \lambda y \lambda y' \lambda n (a\,(y\,n)\,(y'\,n))$$
*)
intros.
elim H3.
elim H4.
elim H5.
(*! math
\item Finally, $\Nil = \lambda a\lambda f\,a$ is extracted trivially
from a proof of \[ $0 \].
*)
intro.
(*! math
\end{itemize}
The term extracted from the all proof is
$$\PC = \lambda k \lambda z \lambda s \lambda l \lambda a (k \;\Idt \;\Idt \;\LC[l] \;\AC[a] \;\Nil)$$ 
\end{proof}
*)
save Complete.

(*! math
\begin{lem}\label{ess}
We define $\sigma_n =  [l/\LC[l],a/\AC[a],x_1/\KK[\overline{1}],\dots,x_n/\KK[\overline{n}]]$ 
where $\KK[q] = \lambda p (\Sub\,p\,q\,z\,s)$. 
If $||t'|| = u$ where
$x_1,\dots x_n$ are distinct and are the free variables of $u$,  then
$||t''||_{x_n\dots x_1} = u$ with
$t''$ the 
normal form of $(t'\sigma_n)\overline{n}$.
\end{lem}

\begin{proof} 
We first notice that 
$$(\LC[l]\,v\,\overline{q}) \sim_\beta (l\,(v\,\KK[\overline{q+1}]\,\overline{q+1})) \;\;\;\; (i)$$
Then we prove the result by induction on $u$:
\begin{itemize}
\item If $u = x_q$, then $t' = x_q$ and
$(t'\sigma_n\,\overline{n}) \sim_{\beta} (\KK[q]\,\overline{n}) \sim_{\beta} (s^{n-q}\,z)$ and we
get what we wanted by an easy induction on $n-q$.
\item If $u = \lambda x_{n+1}\,u_1$, then
$t' = (l\,\lambda x_{n+1}\,t'_1)$ with $||t'_1|| = u_1$.
Using (i), we find $(t'\sigma_n\,\overline{n}) \sim_{\beta}
(\LC[l]\,(\lambda x_{n+1} t'_1\sigma_n)\,\overline{n}) 
\sim_{\beta}
(l\,t'_1\sigma_{n+1}\,\overline{n+1})
\sim_{\beta} (l\,t''_1) = t''$ 
where $t''_1$ is the normal form of
$(t'_1\sigma_{n+1})\overline{n+1}$.
 Using the induction hypothesis,
we find $||t''||_{x_{n}\dots x_1} =
\lambda x_{n+1} ||t''_1||_{x_{n+1}\dots x_1} =
\lambda x_{n+1} u_1 = u$ which is what we wanted.
\item If $u = (u_1\,u_2)$,  then 
$t' = (a\,t'_1\,t'_2)$. We have 
$(t'\sigma_n\,\overline{n}) \sim_{\beta} (\AC[a]\,t'_1\,t'_2\,\overline{n}) \sim_{\beta} 
(a\,(t'_1\sigma_n\,\overline{n})\,(t'_2\sigma_n\,\overline{n}))$ and we
easily get the expected result using the induction hypothesis and the
definition of $||t''||_{x_{n}\dots x_1}$. \qed
\end{itemize}
\end{proof}


\begin{prop}\label{Cextract}
If $(t\,\Idt\,\Idt)$ is $\beta$-equivalent an higher-order representation of a term $u$ then $(\PC\,t)$
is $\beta$-equivalent to an internal
Debruijn representation $t''$ of $u$. 
\end{prop}

\begin{proof}
By definition, we have $(t\,\Idt\,\Idt) \sim_{\beta} \lambda l \lambda a t'$
with $||t'|| = u$. 
We have $(\PC\,t) \sim_{\beta} (t'[l/\LC[l],a/\AC[a]]\,\Nil) =
(t'\sigma_0\,\Nil)$.
Using the previous lemma, we find $(\PC\,t) \sim_{\beta} t''$ with $||t''||_\emptyset = u$
which means that $(\PC\,t)$ is $\beta$-equivalent to an internal
Debruijn representation $t''$ of $u$. \qed
\end{proof}

\begin{thm}\label{truthreprbis}
For any term $t$ and any formula $f$, if $\vdash_{AF_2} t
: \[ Truth M o e f \]$ then $(t)\lambda x\,x\;\lambda x\,x$ is
$\beta$-equivalent to the
higher-order representation of a $\lambda$-term $u$ with
$\vdash_S u : f$.
\end{thm}

This theorem is a refinement of the proposition \ref{truthrepr}.

\begin{proof}
Let t be a term such that $\vdash_{AF_2} t
: \[ Truth M o e f \]$. Then by the proposition \ref{truthrepr}
$(t\,\Idt\,\Idt)$ is $\beta$-equivalent to an 
higher-order representation of a term $u$.
Using the proposition \ref{Cextract}, we find
that $(\CP\,t) \sim_{\beta} t''$ where $t''$ is an
internal Debruijn representation $t''$ of a term $u$.

Moreover, using the proof of the theorem completeness, we find
$\vdash_{AF_2} (\CP\,t) : \[ Prouvable nil f \]$, and using the theorem
\ref{prvrepr} we find that $(\CP\,t)$ is $\beta$-equivalent to an
internal Debruijn representation $t''_0$ of a term $u'$ with $\vdash_S
u' : f$.  But using the definition of internal Debruijn representation
we have $t'' \sim_{\beta} t''_0$ implies $t'' = t''_0$ (because
$t''$ and $t''_0$ are in normal form and $\beta$-equivalent to the
same term) and therefore $u =
u'$

Thus, $(\CP\,t)$ is $\beta$-equivalent to an internal Debruijn
representation $t''$ of a term $u$ with $\vdash_S u : f$. \qed \end{proof}

\begin{thm}\label{main}
Any term $T$ extracted from a proof of the completeness
(resp. correctness) theorem translates an higher-order (resp. internal
Debruijn) representation of a term $u$ such that $\vdash_S u : f$ into 
an internal Debruijn  (resp. higher-order) representation of a term
$u'$ such that $\vdash_S u' : f$.
\end{thm}

\begin{proof}
This theorem is an immediate consequence of the theorems
\ref{prvrepr} and \ref{truthreprbis} using the following properties
(which are the converse of these theorems):
\begin{enumerate}
\item If $t$ is an internal Debruijn representation of $u$ and
$\vdash_S u : f$ then $\vdash_{AF_2} t : \emptyset \Vdash f$.   
We prove this by proving by induction on the proof that
$||t||_{x_n\dots x_1} = u$ and $x_1 : f_1, \dots, x_n : f_n
\vdash_S u : f$ implies $\vdash_{AF_2} t : f_n\dots f_1 \Vdash f$.
The proof is easy using the definition of $||t||_{x_n\dots x_1}$.
\item If $t$ is an higher-order representation of $u$ and
$\vdash_S u : f$ then $\vdash_{AF_2} t : \[ Truth M o e f \]$. 
This result is a consequence of (1), the correctness theorem and the proposition
\ref{extractone}. \qed 
\end{enumerate}
\end{proof}

\bibliography{/home/raffalli/tex/Biblio/biblio}
\bibliographystyle{plain}

*)
 









